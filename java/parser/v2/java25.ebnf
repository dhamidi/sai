// Java 25 Grammar (Merged Lexical + Syntactic)
// Based on JLS 25, Chapters 3 and 19
//
// Convention:
// - Uppercase productions are tokens (lexer matches these)
// - Lowercase productions are syntax rules (parser matches these)

// =============================================================================
// LEXICAL GRAMMAR (Chapter 3)
// =============================================================================

// §3.3 Unicode Escapes
UnicodeInputCharacter = UnicodeEscape | RawInputCharacter .
UnicodeEscape = "\\" UnicodeMarker HexDigit HexDigit HexDigit HexDigit .
UnicodeMarker = "u" { "u" } .
RawInputCharacter = "\u0000" … "\uffff" .

// §3.4 Line Terminators
LineTerminator = "\n" | "\r" | "\r" "\n" .
InputCharacter = UnicodeInputCharacter .

// §3.6 White Space
WhiteSpace = " " | "\t" | "\f" | LineTerminator .

// §3.7 Comments
Comment = TraditionalComment | EndOfLineComment .
TraditionalComment = "/" "*" CommentTail .
CommentTail = "*" CommentTailStar | NotStar CommentTail .
CommentTailStar = "/" | "*" CommentTailStar | NotStarNotSlash CommentTail .
NotStar = InputCharacter | LineTerminator .
NotStarNotSlash = InputCharacter | LineTerminator .
EndOfLineComment = "/" "/" { InputCharacter } .

// §3.8 Identifiers
Identifier = JavaLetter { JavaLetterOrDigit } .
JavaLetter = "a" … "z" | "A" … "Z" | "_" | "$" .
JavaLetterOrDigit = JavaLetter | "0" … "9" .

// §3.9 Keywords
// Keywords are matched as Identifier by the lexer, then the parser
// matches them by literal value. This avoids longest-match conflicts.

// §3.10 Literals
IntegerLiteral =
    DecimalIntegerLiteral |
    HexIntegerLiteral |
    OctalIntegerLiteral |
    BinaryIntegerLiteral .
DecimalIntegerLiteral = DecimalNumeral [ IntegerTypeSuffix ] .
HexIntegerLiteral = HexNumeral [ IntegerTypeSuffix ] .
OctalIntegerLiteral = OctalNumeral [ IntegerTypeSuffix ] .
BinaryIntegerLiteral = BinaryNumeral [ IntegerTypeSuffix ] .
IntegerTypeSuffix = "l" | "L" .

DecimalNumeral = "0" | NonZeroDigit [ Digits ] | NonZeroDigit Underscores Digits .
NonZeroDigit = "1" … "9" .
Digits = Digit | Digit [ DigitsAndUnderscores ] Digit .
Digit = "0" | NonZeroDigit .
DigitsAndUnderscores = DigitOrUnderscore { DigitOrUnderscore } .
DigitOrUnderscore = Digit | "_" .
Underscores = "_" { "_" } .

HexNumeral = "0" ( "x" | "X" ) HexDigits .
HexDigits = HexDigit | HexDigit [ HexDigitsAndUnderscores ] HexDigit .
HexDigit = "0" … "9" | "a" … "f" | "A" … "F" .
HexDigitsAndUnderscores = HexDigitOrUnderscore { HexDigitOrUnderscore } .
HexDigitOrUnderscore = HexDigit | "_" .

OctalNumeral = "0" ( OctalDigits | Underscores OctalDigits ) .
OctalDigits = OctalDigit | OctalDigit [ OctalDigitsAndUnderscores ] OctalDigit .
OctalDigit = "0" … "7" .
OctalDigitsAndUnderscores = OctalDigitOrUnderscore { OctalDigitOrUnderscore } .
OctalDigitOrUnderscore = OctalDigit | "_" .

BinaryNumeral = "0" ( "b" | "B" ) BinaryDigits .
BinaryDigits = BinaryDigit | BinaryDigit [ BinaryDigitsAndUnderscores ] BinaryDigit .
BinaryDigit = "0" | "1" .
BinaryDigitsAndUnderscores = BinaryDigitOrUnderscore { BinaryDigitOrUnderscore } .
BinaryDigitOrUnderscore = BinaryDigit | "_" .

FloatingPointLiteral = DecimalFloatingPointLiteral | HexadecimalFloatingPointLiteral .
DecimalFloatingPointLiteral =
    Digits "." [ Digits ] [ ExponentPart ] [ FloatTypeSuffix ] |
    "." Digits [ ExponentPart ] [ FloatTypeSuffix ] |
    Digits ExponentPart [ FloatTypeSuffix ] |
    Digits [ ExponentPart ] FloatTypeSuffix .
ExponentPart = ( "e" | "E" ) [ Sign ] Digits .
Sign = "+" | "-" .
FloatTypeSuffix = "f" | "F" | "d" | "D" .

HexadecimalFloatingPointLiteral = HexSignificand BinaryExponent [ FloatTypeSuffix ] .
HexSignificand =
    HexNumeral [ "." ] |
    "0" ( "x" | "X" ) [ HexDigits ] "." HexDigits .
BinaryExponent = ( "p" | "P" ) [ Sign ] Digits .

BooleanLiteral = "true" | "false" .

CharacterLiteral = "'" ( SingleCharacter | EscapeSequence ) "'" .
SingleCharacter = InputCharacter .

StringLiteral = "\"" { StringCharacter } "\"" .
StringCharacter = InputCharacter | EscapeSequence .

TextBlock = "\"" "\"" "\"" { LineTerminator | TextBlockCharacter } "\"" "\"" "\"" .
TextBlockCharacter = InputCharacter | EscapeSequence .

EscapeSequence = "\\" ( "b" | "s" | "t" | "n" | "f" | "r" | "\"" | "'" | "\\" | LineTerminator | OctalEscape ) .
OctalEscape = OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit .
ZeroToThree = "0" … "3" .

NullLiteral = "null" .

Literal =
    IntegerLiteral |
    FloatingPointLiteral |
    BooleanLiteral |
    CharacterLiteral |
    StringLiteral |
    TextBlock |
    NullLiteral .

// §3.11 Separators
LPAREN = "(" .
RPAREN = ")" .
LBRACE = "{" .
RBRACE = "}" .
LBRACKET = "[" .
RBRACKET = "]" .
SEMI = ";" .
COMMA = "," .
DOT = "." .
ELLIPSIS = "..." .
AT = "@" .
COLONCOLON = "::" .

// §3.12 Operators
ASSIGN = "=" .
GT = ">" .
LT = "<" .
BANG = "!" .
TILDE = "~" .
QUESTION = "?" .
COLON = ":" .
ARROW = "->" .
EQ = "==" .
GE = ">=" .
LE = "<=" .
NE = "!=" .
AND = "&&" .
OR = "||" .
INC = "++" .
DEC = "--" .
PLUS = "+" .
MINUS = "-" .
STAR = "*" .
SLASH = "/" .
AMP = "&" .
PIPE = "|" .
CARET = "^" .
MOD = "%" .
LSHIFT = "<<" .
RSHIFT = ">>" .
URSHIFT = ">>>" .
PLUSEQ = "+=" .
MINUSEQ = "-=" .
STAREQ = "*=" .
SLASHEQ = "/=" .
AMPEQ = "&=" .
PIPEEQ = "|=" .
CARETEQ = "^=" .
MODEQ = "%=" .
LSHIFTEQ = "<<=" .
RSHIFTEQ = ">>=" .
URSHIFTEQ = ">>>=" .

// =============================================================================
// SYNTACTIC GRAMMAR (Chapter 19)
// =============================================================================

// Productions from §4 (Types, Values, and Variables)

primitiveType =
    { annotation } numericType |
    { annotation } "boolean" .

numericType = integralType | floatingPointType .

integralType = "byte" | "short" | "int" | "long" | "char" .

floatingPointType = "float" | "double" .

referenceType = classOrInterfaceType | typeVariable | arrayType .

classOrInterfaceType = classType | interfaceType .

classType =
    { annotation } typeIdentifier [ typeArguments ] |
    packageName "." { annotation } typeIdentifier [ typeArguments ] |
    classOrInterfaceType "." { annotation } typeIdentifier [ typeArguments ] .

interfaceType = classType .

typeVariable = { annotation } typeIdentifier .

arrayType =
    primitiveType dims |
    classOrInterfaceType dims |
    typeVariable dims .

dims = { annotation } "[" "]" { { annotation } "[" "]" } .

typeParameter = { typeParameterModifier } typeIdentifier [ typeBound ] .

typeParameterModifier = annotation .

typeBound =
    "extends" typeVariable |
    "extends" classOrInterfaceType { additionalBound } .

additionalBound = "&" interfaceType .

typeArguments = "<" typeArgumentList ">" .

typeArgumentList = typeArgument { "," typeArgument } .

typeArgument = referenceType | wildcard .

wildcard = { annotation } "?" [ wildcardBounds ] .

wildcardBounds = "extends" referenceType | "super" referenceType .

// Productions from §6 (Names)

typeIdentifier = Identifier .
unqualifiedMethodIdentifier = Identifier .

moduleName = Identifier | moduleName "." Identifier .

packageName = Identifier | packageName "." Identifier .

typeName = typeIdentifier | packageOrTypeName "." typeIdentifier .

expressionName = Identifier | ambiguousName "." Identifier .

methodName = unqualifiedMethodIdentifier .

packageOrTypeName = Identifier | packageOrTypeName "." Identifier .

ambiguousName = Identifier | ambiguousName "." Identifier .

// Productions from §7 (Packages and Modules)

compilationUnit =
    ordinaryCompilationUnit |
    compactCompilationUnit |
    modularCompilationUnit .

ordinaryCompilationUnit =
    [ packageDeclaration ] { importDeclaration }
    { topLevelClassOrInterfaceDeclaration } .

compactCompilationUnit =
    { importDeclaration } { classMemberDeclarationNoMethod }
    methodDeclaration { classMemberDeclaration } .

classMemberDeclarationNoMethod =
    fieldDeclaration |
    classDeclaration |
    interfaceDeclaration |
    ";" .

modularCompilationUnit = { importDeclaration } moduleDeclaration .

packageDeclaration = { packageModifier } "package" Identifier { "." Identifier } ";" .

packageModifier = annotation .

importDeclaration =
    singleTypeImportDeclaration |
    typeImportOnDemandDeclaration |
    singleStaticImportDeclaration |
    staticImportOnDemandDeclaration |
    singleModuleImportDeclaration .

singleTypeImportDeclaration = "import" typeName ";" .

typeImportOnDemandDeclaration = "import" packageOrTypeName "." "*" ";" .

singleStaticImportDeclaration = "import" "static" typeName "." Identifier ";" .

staticImportOnDemandDeclaration = "import" "static" typeName "." "*" ";" .

singleModuleImportDeclaration = "import" "module" moduleName ";" .

topLevelClassOrInterfaceDeclaration =
    classDeclaration |
    interfaceDeclaration |
    ";" .

moduleDeclaration =
    { annotation } [ "open" ] "module" Identifier { "." Identifier }
    "{" { moduleDirective } "}" .

moduleDirective =
    "requires" { requiresModifier } moduleName ";" |
    "exports" packageName [ "to" moduleName { "," moduleName } ] ";" |
    "opens" packageName [ "to" moduleName { "," moduleName } ] ";" |
    "uses" typeName ";" |
    "provides" typeName "with" typeName { "," typeName } ";" .

requiresModifier = "transitive" | "static" .

// Productions from §8 (Classes)

classDeclaration =
    normalClassDeclaration |
    enumDeclaration |
    recordDeclaration .

normalClassDeclaration =
    { classModifier } "class" typeIdentifier [ typeParameters ]
    [ classExtends ] [ classImplements ] [ classPermits ] classBody .

classModifier =
    annotation | "public" | "protected" | "private" |
    "abstract" | "static" | "final" | "sealed" | "non-sealed" | "strictfp" .

typeParameters = "<" typeParameterList ">" .

typeParameterList = typeParameter { "," typeParameter } .

classExtends = "extends" classType .

classImplements = "implements" interfaceTypeList .

interfaceTypeList = interfaceType { "," interfaceType } .

classPermits = "permits" typeName { "," typeName } .

classBody = "{" { classBodyDeclaration } "}" .

classBodyDeclaration =
    classMemberDeclaration |
    instanceInitializer |
    staticInitializer |
    constructorDeclaration .

classMemberDeclaration =
    fieldDeclaration |
    methodDeclaration |
    classDeclaration |
    interfaceDeclaration |
    ";" .

fieldDeclaration = { fieldModifier } unannType variableDeclaratorList ";" .

fieldModifier =
    annotation | "public" | "protected" | "private" |
    "static" | "final" | "transient" | "volatile" .

variableDeclaratorList = variableDeclarator { "," variableDeclarator } .

variableDeclarator = variableDeclaratorId [ "=" variableInitializer ] .

variableDeclaratorId = Identifier [ dims ] | "_" .

variableInitializer = expression | arrayInitializer .

unannType = unannPrimitiveType | unannReferenceType .

unannPrimitiveType = numericType | "boolean" .

unannReferenceType =
    unannClassOrInterfaceType |
    unannTypeVariable |
    unannArrayType .

unannClassOrInterfaceType = unannClassType | unannInterfaceType .

unannClassType =
    typeIdentifier [ typeArguments ] |
    packageName "." { annotation } typeIdentifier [ typeArguments ] |
    unannClassOrInterfaceType "." { annotation } typeIdentifier [ typeArguments ] .

unannInterfaceType = unannClassType .

unannTypeVariable = typeIdentifier .

unannArrayType =
    unannPrimitiveType dims |
    unannClassOrInterfaceType dims |
    unannTypeVariable dims .

methodDeclaration = { methodModifier } methodHeader methodBody .

methodModifier =
    annotation | "public" | "protected" | "private" |
    "abstract" | "static" | "final" | "synchronized" | "native" | "strictfp" .

methodHeader =
    result methodDeclarator [ throws ] |
    typeParameters { annotation } result methodDeclarator [ throws ] .

result = unannType | "void" .

methodDeclarator =
    Identifier "(" [ receiverParameter "," ] [ formalParameterList ] ")" [ dims ] .

receiverParameter = { annotation } unannType [ Identifier "." ] "this" .

formalParameterList = formalParameter { "," formalParameter } .

formalParameter =
    { variableModifier } unannType variableDeclaratorId |
    variableArityParameter .

variableArityParameter =
    { variableModifier } unannType { annotation } "..." Identifier .

variableModifier = annotation | "final" .

throws = "throws" exceptionTypeList .

exceptionTypeList = exceptionType { "," exceptionType } .

exceptionType = classType | typeVariable .

methodBody = block | ";" .

instanceInitializer = block .

staticInitializer = "static" block .

constructorDeclaration =
    { constructorModifier } constructorDeclarator [ throws ] constructorBody .

constructorModifier = annotation | "public" | "protected" | "private" .

constructorDeclarator =
    [ typeParameters ] simpleTypeName
    "(" [ receiverParameter "," ] [ formalParameterList ] ")" .

simpleTypeName = typeIdentifier .

constructorBody =
    "{" [ blockStatements ] constructorInvocation [ blockStatements ] "}" |
    "{" [ blockStatements ] "}" .

constructorInvocation =
    [ typeArguments ] "this" "(" [ argumentList ] ")" ";" |
    [ typeArguments ] "super" "(" [ argumentList ] ")" ";" |
    expressionName "." [ typeArguments ] "super" "(" [ argumentList ] ")" ";" |
    primary "." [ typeArguments ] "super" "(" [ argumentList ] ")" ";" .

enumDeclaration =
    { classModifier } "enum" typeIdentifier [ classImplements ] enumBody .

enumBody = "{" [ enumConstantList ] [ "," ] [ enumBodyDeclarations ] "}" .

enumConstantList = enumConstant { "," enumConstant } .

enumConstant =
    { enumConstantModifier } Identifier [ "(" [ argumentList ] ")" ] [ classBody ] .

enumConstantModifier = annotation .

enumBodyDeclarations = ";" { classBodyDeclaration } .

recordDeclaration =
    { classModifier } "record" typeIdentifier [ typeParameters ] recordHeader
    [ classImplements ] recordBody .

recordHeader = "(" [ recordComponentList ] ")" .

recordComponentList = recordComponent { "," recordComponent } .

recordComponent =
    { recordComponentModifier } unannType Identifier |
    variableArityRecordComponent .

variableArityRecordComponent =
    { recordComponentModifier } unannType { annotation } "..." Identifier .

recordComponentModifier = annotation .

recordBody = "{" { recordBodyDeclaration } "}" .

recordBodyDeclaration =
    classBodyDeclaration |
    compactConstructorDeclaration .

compactConstructorDeclaration =
    { constructorModifier } simpleTypeName constructorBody .

// Productions from §9 (Interfaces)

interfaceDeclaration =
    normalInterfaceDeclaration |
    annotationInterfaceDeclaration .

normalInterfaceDeclaration =
    { interfaceModifier } "interface" typeIdentifier [ typeParameters ]
    [ interfaceExtends ] [ interfacePermits ] interfaceBody .

interfaceModifier =
    annotation | "public" | "protected" | "private" |
    "abstract" | "static" | "sealed" | "non-sealed" | "strictfp" .

interfaceExtends = "extends" interfaceTypeList .

interfacePermits = "permits" typeName { "," typeName } .

interfaceBody = "{" { interfaceMemberDeclaration } "}" .

interfaceMemberDeclaration =
    constantDeclaration |
    interfaceMethodDeclaration |
    classDeclaration |
    interfaceDeclaration |
    ";" .

constantDeclaration = { constantModifier } unannType variableDeclaratorList ";" .

constantModifier = annotation | "public" | "static" | "final" .

interfaceMethodDeclaration =
    { interfaceMethodModifier } methodHeader methodBody .

interfaceMethodModifier =
    annotation | "public" | "private" |
    "abstract" | "default" | "static" | "strictfp" .

annotationInterfaceDeclaration =
    { interfaceModifier } "@" "interface" typeIdentifier annotationInterfaceBody .

annotationInterfaceBody = "{" { annotationInterfaceMemberDeclaration } "}" .

annotationInterfaceMemberDeclaration =
    annotationInterfaceElementDeclaration |
    constantDeclaration |
    classDeclaration |
    interfaceDeclaration |
    ";" .

annotationInterfaceElementDeclaration =
    { annotationInterfaceElementModifier } unannType Identifier "(" ")" [ dims ]
    [ defaultValue ] ";" .

annotationInterfaceElementModifier = annotation | "public" | "abstract" .

defaultValue = "default" elementValue .

annotation =
    normalAnnotation |
    markerAnnotation |
    singleElementAnnotation .

normalAnnotation = "@" typeName "(" [ elementValuePairList ] ")" .

elementValuePairList = elementValuePair { "," elementValuePair } .

elementValuePair = Identifier "=" elementValue .

elementValue =
    conditionalExpression |
    elementValueArrayInitializer |
    annotation .

elementValueArrayInitializer = "{" [ elementValueList ] [ "," ] "}" .

elementValueList = elementValue { "," elementValue } .

markerAnnotation = "@" typeName .

singleElementAnnotation = "@" typeName "(" elementValue ")" .

// Productions from §10 (Arrays)

arrayInitializer = "{" [ variableInitializerList ] [ "," ] "}" .

variableInitializerList = variableInitializer { "," variableInitializer } .

// Productions from §14 (Blocks, Statements, and Patterns)

block = "{" [ blockStatements ] "}" .

blockStatements = blockStatement { blockStatement } .

blockStatement =
    localClassOrInterfaceDeclaration |
    localVariableDeclarationStatement |
    statement .

localClassOrInterfaceDeclaration =
    classDeclaration |
    normalInterfaceDeclaration .

localVariableDeclarationStatement = localVariableDeclaration ";" .

localVariableDeclaration =
    { variableModifier } localVariableType variableDeclaratorList .

localVariableType = unannType | "var" .

statement =
    statementWithoutTrailingSubstatement |
    labeledStatement |
    ifThenStatement |
    ifThenElseStatement |
    whileStatement |
    forStatement .

statementNoShortIf =
    statementWithoutTrailingSubstatement |
    labeledStatementNoShortIf |
    ifThenElseStatementNoShortIf |
    whileStatementNoShortIf |
    forStatementNoShortIf .

statementWithoutTrailingSubstatement =
    block |
    emptyStatement |
    expressionStatement |
    assertStatement |
    switchStatement |
    doStatement |
    breakStatement |
    continueStatement |
    returnStatement |
    synchronizedStatement |
    throwStatement |
    tryStatement |
    yieldStatement .

emptyStatement = ";" .

labeledStatement = Identifier ":" statement .

labeledStatementNoShortIf = Identifier ":" statementNoShortIf .

expressionStatement = statementExpression ";" .

statementExpression =
    assignment |
    preIncrementExpression |
    preDecrementExpression |
    postIncrementExpression |
    postDecrementExpression |
    methodInvocation |
    classInstanceCreationExpression .

ifThenStatement = "if" "(" expression ")" statement .

ifThenElseStatement = "if" "(" expression ")" statementNoShortIf "else" statement .

ifThenElseStatementNoShortIf =
    "if" "(" expression ")" statementNoShortIf "else" statementNoShortIf .

assertStatement =
    "assert" expression ";" |
    "assert" expression ":" expression ";" .

switchStatement = "switch" "(" expression ")" switchBlock .

switchBlock =
    "{" switchRule { switchRule } "}" |
    "{" { switchBlockStatementGroup } { switchLabel ":" } "}" .

switchRule =
    switchLabel "->" expression ";" |
    switchLabel "->" block |
    switchLabel "->" throwStatement .

switchBlockStatementGroup = switchLabel ":" { switchLabel ":" } blockStatements .

switchLabel =
    "case" caseConstant { "," caseConstant } |
    "case" "null" [ "," "default" ] |
    "case" casePattern { "," casePattern } [ guard ] |
    "default" .

caseConstant = conditionalExpression .

casePattern = pattern .

guard = "when" expression .

whileStatement = "while" "(" expression ")" statement .

whileStatementNoShortIf = "while" "(" expression ")" statementNoShortIf .

doStatement = "do" statement "while" "(" expression ")" ";" .

forStatement = basicForStatement | enhancedForStatement .

forStatementNoShortIf = basicForStatementNoShortIf | enhancedForStatementNoShortIf .

basicForStatement =
    "for" "(" [ forInit ] ";" [ expression ] ";" [ forUpdate ] ")" statement .

basicForStatementNoShortIf =
    "for" "(" [ forInit ] ";" [ expression ] ";" [ forUpdate ] ")" statementNoShortIf .

forInit = statementExpressionList | localVariableDeclaration .

forUpdate = statementExpressionList .

statementExpressionList = statementExpression { "," statementExpression } .

enhancedForStatement =
    "for" "(" localVariableDeclaration ":" expression ")" statement .

enhancedForStatementNoShortIf =
    "for" "(" localVariableDeclaration ":" expression ")" statementNoShortIf .

breakStatement = "break" [ Identifier ] ";" .

yieldStatement = "yield" expression ";" .

continueStatement = "continue" [ Identifier ] ";" .

returnStatement = "return" [ expression ] ";" .

throwStatement = "throw" expression ";" .

synchronizedStatement = "synchronized" "(" expression ")" block .

tryStatement =
    "try" block catches |
    "try" block [ catches ] finally |
    tryWithResourcesStatement .

catches = catchClause { catchClause } .

catchClause = "catch" "(" catchFormalParameter ")" block .

catchFormalParameter =
    { variableModifier } catchType variableDeclaratorId .

catchType = unannClassType { "|" classType } .

finally = "finally" block .

tryWithResourcesStatement =
    "try" resourceSpecification block [ catches ] [ finally ] .

resourceSpecification = "(" resourceList [ ";" ] ")" .

resourceList = resource { ";" resource } .

resource = localVariableDeclaration | variableAccess .

variableAccess = expressionName | fieldAccess .

pattern = typePattern | recordPattern .

typePattern = localVariableDeclaration .

recordPattern = referenceType "(" [ componentPatternList ] ")" .

componentPatternList = componentPattern { "," componentPattern } .

componentPattern = pattern | matchAllPattern .

matchAllPattern = "_" .

// Productions from §15 (Expressions)

primary = primaryNoNewArray | arrayCreationExpression .

primaryNoNewArray =
    Literal |
    classLiteral |
    "this" |
    typeName "." "this" |
    "(" expression ")" |
    classInstanceCreationExpression |
    fieldAccess |
    arrayAccess |
    methodInvocation |
    methodReference .

classLiteral =
    typeName { "[" "]" } "." "class" |
    numericType { "[" "]" } "." "class" |
    "boolean" { "[" "]" } "." "class" |
    "void" "." "class" .

classInstanceCreationExpression =
    unqualifiedClassInstanceCreationExpression |
    expressionName "." unqualifiedClassInstanceCreationExpression |
    primary "." unqualifiedClassInstanceCreationExpression .

unqualifiedClassInstanceCreationExpression =
    "new" [ typeArguments ]
    classOrInterfaceTypeToInstantiate "(" [ argumentList ] ")" [ classBody ] .

classOrInterfaceTypeToInstantiate =
    { annotation } Identifier { "." { annotation } Identifier }
    [ typeArgumentsOrDiamond ] .

typeArgumentsOrDiamond = typeArguments | "<" ">" .

arrayCreationExpression =
    arrayCreationExpressionWithoutInitializer |
    arrayCreationExpressionWithInitializer .

arrayCreationExpressionWithoutInitializer =
    "new" primitiveType dimExprs [ dims ] |
    "new" classOrInterfaceType dimExprs [ dims ] .

arrayCreationExpressionWithInitializer =
    "new" primitiveType dims arrayInitializer |
    "new" classOrInterfaceType dims arrayInitializer .

dimExprs = dimExpr { dimExpr } .

dimExpr = { annotation } "[" expression "]" .

arrayAccess =
    expressionName "[" expression "]" |
    primaryNoNewArray "[" expression "]" |
    arrayCreationExpressionWithInitializer "[" expression "]" .

fieldAccess =
    primary "." Identifier |
    "super" "." Identifier |
    typeName "." "super" "." Identifier .

methodInvocation =
    methodName "(" [ argumentList ] ")" |
    typeName "." [ typeArguments ] Identifier "(" [ argumentList ] ")" |
    expressionName "." [ typeArguments ] Identifier "(" [ argumentList ] ")" |
    primary "." [ typeArguments ] Identifier "(" [ argumentList ] ")" |
    "super" "." [ typeArguments ] Identifier "(" [ argumentList ] ")" |
    typeName "." "super" "." [ typeArguments ] Identifier "(" [ argumentList ] ")" .

argumentList = expression { "," expression } .

methodReference =
    expressionName "::" [ typeArguments ] Identifier |
    primary "::" [ typeArguments ] Identifier |
    referenceType "::" [ typeArguments ] Identifier |
    "super" "::" [ typeArguments ] Identifier |
    typeName "." "super" "::" [ typeArguments ] Identifier |
    classType "::" [ typeArguments ] "new" |
    arrayType "::" "new" .

expression = lambdaExpression | assignmentExpression .

lambdaExpression = lambdaParameters "->" lambdaBody .

lambdaParameters =
    "(" [ lambdaParameterList ] ")" |
    conciseLambdaParameter .

lambdaParameterList =
    normalLambdaParameter { "," normalLambdaParameter } |
    conciseLambdaParameter { "," conciseLambdaParameter } .

normalLambdaParameter =
    { variableModifier } lambdaParameterType variableDeclaratorId |
    variableArityParameter .

lambdaParameterType = unannType | "var" .

conciseLambdaParameter = Identifier | "_" .

lambdaBody = expression | block .

assignmentExpression = conditionalExpression | assignment .

assignment = leftHandSide assignmentOperator expression .

leftHandSide = expressionName | fieldAccess | arrayAccess .

assignmentOperator =
    "=" | "*=" | "/=" | "%=" | "+=" | "-=" |
    "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" .

conditionalExpression =
    conditionalOrExpression |
    conditionalOrExpression "?" expression ":" conditionalExpression |
    conditionalOrExpression "?" expression ":" lambdaExpression .

conditionalOrExpression =
    conditionalAndExpression |
    conditionalOrExpression "||" conditionalAndExpression .

conditionalAndExpression =
    inclusiveOrExpression |
    conditionalAndExpression "&&" inclusiveOrExpression .

inclusiveOrExpression =
    exclusiveOrExpression |
    inclusiveOrExpression "|" exclusiveOrExpression .

exclusiveOrExpression =
    andExpression |
    exclusiveOrExpression "^" andExpression .

andExpression =
    equalityExpression |
    andExpression "&" equalityExpression .

equalityExpression =
    relationalExpression |
    equalityExpression "==" relationalExpression |
    equalityExpression "!=" relationalExpression .

relationalExpression =
    shiftExpression |
    relationalExpression "<" shiftExpression |
    relationalExpression ">" shiftExpression |
    relationalExpression "<=" shiftExpression |
    relationalExpression ">=" shiftExpression |
    instanceofExpression .

instanceofExpression =
    relationalExpression "instanceof" referenceType |
    relationalExpression "instanceof" pattern .

shiftExpression =
    additiveExpression |
    shiftExpression "<<" additiveExpression |
    shiftExpression ">>" additiveExpression |
    shiftExpression ">>>" additiveExpression .

additiveExpression =
    multiplicativeExpression |
    additiveExpression "+" multiplicativeExpression |
    additiveExpression "-" multiplicativeExpression .

multiplicativeExpression =
    unaryExpression |
    multiplicativeExpression "*" unaryExpression |
    multiplicativeExpression "/" unaryExpression |
    multiplicativeExpression "%" unaryExpression .

unaryExpression =
    preIncrementExpression |
    preDecrementExpression |
    "+" unaryExpression |
    "-" unaryExpression |
    unaryExpressionNotPlusMinus .

preIncrementExpression = "++" unaryExpression .

preDecrementExpression = "--" unaryExpression .

unaryExpressionNotPlusMinus =
    postfixExpression |
    "~" unaryExpression |
    "!" unaryExpression |
    castExpression |
    switchExpression .

postfixExpression =
    primary |
    expressionName |
    postIncrementExpression |
    postDecrementExpression .

postIncrementExpression = postfixExpression "++" .

postDecrementExpression = postfixExpression "--" .

castExpression =
    "(" primitiveType ")" unaryExpression |
    "(" referenceType { additionalBound } ")" unaryExpressionNotPlusMinus |
    "(" referenceType { additionalBound } ")" lambdaExpression .

switchExpression = "switch" "(" expression ")" switchBlock .
