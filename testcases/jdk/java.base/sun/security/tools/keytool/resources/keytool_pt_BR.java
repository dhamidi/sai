package sun.security.tools.keytool.resources;

import java.util.ListResourceBundle;

public final class keytool_pt_BR extends ListResourceBundle {
    protected final Object[][] getContents() {
        return new Object[][] {
            { ".Empty.value.", "(Valor vazio)" },
            { ".OPTION.", " [OPTION]..." },
            { ".PATTERN.printX509Cert.with.weak", "Propriet\u00E1rio: {0}\nEmissor: {1}\nN\u00FAmero de s\u00E9rie: {2}\nV\u00E1lido de: {3} at\u00E9: {4}\nFingerprints do certificado:\n\t SHA1: {5}\n\t SHA256: {6}\nNome do algoritmo de assinatura: {7}\nAlgoritmo de Chave P\u00FAblica do Assunto: {8}\nVers\u00E3o: {9}" },
            { ".RETURN.if.same.as.for.otherAlias.", "\t(RETURN se for igual ao de <{0}>)" },
            { ".RETURN.if.same.as.keystore.password.", "\t(RETURN se for igual \u00E0 senha da \u00E1rea do armazenamento de chaves):  " },
            { ".Storing.ksfname.", "[Armazenando {0}]" },
            { ".The.integrity.of.the.information.stored.in.the.srckeystore.", "* A integridade das informa\u00E7\u00F5es armazenadas no srckeystore  *\n* N\u00C3O foi verificada!  Para que seja poss\u00EDvel verificar sua integridade, *\n* voc\u00EA deve fornecer a senha do srckeystore.                  *" },
            { ".The.integrity.of.the.information.stored.in.your.keystore.", "* A integridade das informa\u00E7\u00F5es armazenadas na sua \u00E1rea de armazenamento de chaves  *\n* N\u00C3O foi verificada!  Para que seja poss\u00EDvel verificar sua integridade, *\n* voc\u00EA deve fornecer a senha da \u00E1rea de armazenamento de chaves.                  *" },
            { ".WARNING.WARNING.WARNING.", "*****************  WARNING WARNING WARNING  *****************" },
            { ".defaultValue.", "  [{0}]:  " },
            { ".is.not.trusted.", "... n\u00E3o \u00E9 confi\u00E1vel. " },
            { ".keypass.and.new.can.not.be.specified.if.storetype.is.{0}", "-keypass e -new n\u00E3o podem ser especificados se -storetype for {0}" },
            { ".keypasswd.commands.not.supported.if.storetype.is.PKCS12", "comandos -keypasswd n\u00E3o suportados se -storetype for PKCS12" },
            { ".keystore.must.be.NONE.if.storetype.is.{0}", "-keystore deve ser NONE se -storetype for {0}" },
            { ".storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}", "comandos -storepasswd e -keypasswd n\u00E3o suportados se -storetype for {0}" },
            { "Alias.alias.does.not.exist", "O alias <{0}> n\u00E3o existe" },
            { "Alias.alias.has.no.certificate", "O alias <{0}> n\u00E3o tem certificado" },
            { "Alias.alias.has.no.key", "O alias <{0}> n\u00E3o tem chave" },
            { "Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key", "O alias <{0}> faz refer\u00EAncia a um tipo de entrada que n\u00E3o \u00E9 uma entrada de chave privada. O comando -keyclone oferece suporte somente \u00E0 clonagem de entradas de chave privada" },
            { "Alias.name.alias", "Nome do alias: {0}" },
            { "CRLs.", "CRLs:" },
            { "Cannot.derive.signature.algorithm", "N\u00E3o \u00E9 poss\u00EDvel obter um algoritmo de assinatura" },
            { "Cannot.find.environment.variable.", "N\u00E3o \u00E9 poss\u00EDvel localizar a vari\u00E1vel do ambiente: " },
            { "Cannot.find.file.", "N\u00E3o \u00E9 poss\u00EDvel localizar o arquivo: " },
            { "Certificate.already.exists.in.keystore.under.alias.trustalias.", "O certificado j\u00E1 existe no armazenamento de chaves no alias <{0}>" },
            { "Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.", "O certificado j\u00E1 existe na \u00E1rea de armazenamento de chaves da CA em todo o sistema no alias <{0}>" },
            { "Certificate.chain.in.reply.does.not.verify.", "A cadeia de certificados da resposta n\u00E3o verifica: " },
            { "Certificate.chain.length.", "Comprimento da cadeia de certificados: " },
            { "Certificate.fingerprint.SHA.256.", "Fingerprint (SHA-256) do certificado: " },
            { "Certificate.i.1.", "Certificado[{0,number,integer}]:" },
            { "Certificate.not.imported.alias.alias.already.exists", "Certificado n\u00E3o importado, o alias <{0}> j\u00E1 existe" },
            { "Certificate.owner.", "Propriet\u00E1rio do certificado: " },
            { "Certificate.reply.and.certificate.in.keystore.are.identical", "O certificado da resposta e o certificado da \u00E1rea de armazenamento de chaves s\u00E3o id\u00EAnticos" },
            { "Certificate.reply.does.not.contain.public.key.for.alias.", "A resposta do certificado n\u00E3o cont\u00E9m a chave p\u00FAblica de <{0}>" },
            { "Certificate.reply.was.installed.in.keystore", "A resposta do certificado foi instalada na \u00E1rea de armazenamento de chaves" },
            { "Certificate.reply.was.not.installed.in.keystore", "A resposta do certificado n\u00E3o foi instalada na \u00E1rea de armazenamento de chaves" },
            { "Certificate.stored.in.file.filename.", "Certificado armazenado no arquivo <{0}>" },
            { "Certificate.was.added.to.keystore", "O certificado foi adicionado \u00E0 \u00E1rea de armazenamento de chaves" },
            { "Certificate.was.not.added.to.keystore", "O certificado n\u00E3o foi adicionado \u00E0 \u00E1rea de armazenamento de chaves" },
            { "Certification.request.stored.in.file.filename.", "Solicita\u00E7\u00E3o de certificado armazenada no arquivo <{0}>" },
            { "Changes.an.entry.s.alias", "Altera um alias de entrada" },
            { "Changes.the.key.password.of.an.entry", "Altera a senha da chave de uma entrada" },
            { "Changes.the.store.password.of.a.keystore", "Altera a senha de armazenamento de uma \u00E1rea de armazenamento de chaves" },
            { "Clones.a.key.entry", "Clona uma entrada de chave" },
            { "Command.option.flag.needs.an.argument.", "A op\u00E7\u00E3o de comando {0} precisa de um argumento." },
            { "Commands.", "Comandos:" },
            { "Creating.keystore.entry.for.id.getName.", "Criando entrada da \u00E1rea do armazenamento de chaves para <{0}> ..." },
            { "Creation.date.keyStore.getCreationDate.alias.", "Data de cria\u00E7\u00E3o: {0,date}" },
            { "Deletes.an.entry", "Exclui uma entrada" },
            { "Destination.alias.dest.already.exists", "O alias de destino <{0}> j\u00E1 existe" },
            { "Do.you.still.want.to.add.it.no.", "Ainda deseja adicion\u00E1-lo? [n\u00E3o]:  " },
            { "Do.you.still.want.to.add.it.to.your.own.keystore.no.", "Ainda deseja adicion\u00E1-lo \u00E0 sua \u00E1rea de armazenamento de chaves? [n\u00E3o]:  " },
            { "Empty.input", "Entrada vazia" },
            { "Enter.alias.name.", "Informe o nome do alias:  " },
            { "Enter.destination.keystore.password.", "Informe a senha da \u00E1rea de armazenamento de chaves de destino:  " },
            { "Enter.key.password.for.alias.", "Informar a senha da chave de <{0}>" },
            { "Enter.keystore.password.", "Informe a senha da \u00E1rea de armazenamento de chaves:  " },
            { "Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.", "Informe o novo nome do alias\t(RETURN para cancelar a importa\u00E7\u00E3o desta entrada):  " },
            { "Enter.prompt.alias.name.", "Informe o nome do alias {0}:  " },
            { "Enter.source.keystore.password.", "Informe a senha da \u00E1rea de armazenamento de chaves de origem:  " },
            { "Enter.the.password.to.be.stored.", "Digite a senha a ser armazenada:  " },
            { "Entry.for.alias.alias.not.imported.", "Entrada do alias {0} n\u00E3o importada." },
            { "Entry.for.alias.alias.successfully.imported.", "Entrada do alias {0} importada com \u00EAxito." },
            { "Entry.type.type.", "Tipo de entrada: {0}" },
            { "Existing.entry.alias.alias.exists.overwrite.no.", "Entrada j\u00E1 existente no alias {0}, substituir? [n\u00E3o]:  " },
            { "Exports.certificate", "Exporta o certificado" },
            { "Extension.Request.", "Solicita\u00E7\u00E3o de Extens\u00E3o:" },
            { "Extensions.", "Extens\u00F5es: " },
            { "Failed.to.establish.chain.from.reply", "Falha ao estabelecer a cadeia a partir da resposta" },
            { "Failed.to.parse.input", "Falha durante o parsing da entrada" },
            { "Generated.keyAlgName.secret.key", "Chave secreta {0} gerada" },
            { "Generated.keysize.bit.keyAlgName.secret.key", "Chave secreta {1} de {0} bits gerada" },
            { "Generates.CRL", "Gera CRL" },
            { "Generates.a.certificate.request", "Gera uma solicita\u00E7\u00E3o de certificado" },
            { "Generates.a.key.pair", "Gera um par de chaves" },
            { "Generates.a.secret.key", "Gera uma chave secreta" },
            { "Generates.a.self.signed.certificate", "Gera um certificado autoassinado" },
            { "Generates.certificate.from.a.certificate.request", "Gera um certificado de uma solicita\u00E7\u00E3o de certificado" },
            { "Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for", "Gerando o par de chaves {1} de {0} bit e o certificado autoassinado ({2}) com uma validade de {3} dias\n\tpara: {4}" },
            { "Illegal.option.", "Op\u00E7\u00E3o inv\u00E1lida:  " },
            { "Illegal.startdate.value", "valor da data inicial inv\u00E1lido" },
            { "Illegal.value.", "Valor inv\u00E1lido: " },
            { "Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled", "Comando de importa\u00E7\u00E3o conclu\u00EDdo:  {0} entradas importadas com \u00EAxito, {1} entradas falharam ou foram canceladas" },
            { "Imports.a.certificate.or.a.certificate.chain", "Importa um certificado ou uma cadeia de certificados" },
            { "Imports.a.password", "Importa uma senha" },
            { "Imports.entries.from.a.JDK.1.1.x.style.identity.database", "Importa entradas de um banco de dados de identidade JDK 1.1.x-style" },
            { "Imports.one.or.all.entries.from.another.keystore", "Importa uma ou todas as entradas de outra \u00E1rea de armazenamento de chaves" },
            { "Incomplete.certificate.chain.in.reply", "Cadeia de certificados incompleta na resposta" },
            { "Input.not.an.X.509.certificate", "A entrada n\u00E3o \u00E9 um certificado X.509" },
            { "Install.reply.anyway.no.", "Instalar resposta assim mesmo? [n\u00E3o]:  " },
            { "Is.name.correct.", "{0} Est\u00E1 correto?" },
            { "Key.and.Certificate.Management.Tool", "Ferramenta de Gerenciamento de Chave e Certificado" },
            { "Key.pair.not.generated.alias.alias.already.exists", "Par de chaves n\u00E3o gerado; o alias <{0}> j\u00E1 existe" },
            { "Key.password.is.too.short.must.be.at.least.6.characters", "A senha da chave \u00E9 muito curta - deve ter, no m\u00EDnimo, 6 caracteres" },
            { "Key.password.must.be.at.least.6.characters", "A senha da chave deve ter, no m\u00EDnimo, 6 caracteres" },
            { "Keystore.entry.for.id.getName.already.exists", "A entrada da \u00E1rea do armazenamento de chaves de <{0}> j\u00E1 existe" },
            { "Keystore.file.does.not.exist.", "O arquivo da \u00E1rea de armazenamento de chaves n\u00E3o existe. " },
            { "Keystore.file.exists.but.is.empty.", "O arquivo da \u00E1rea de armazenamento de chaves existe, mas est\u00E1 vazio: " },
            { "Keystore.password.is.too.short.must.be.at.least.6.characters", "A senha da \u00E1rea de armazenamento de chaves \u00E9 muito curta - ela deve ter, no m\u00EDnimo, 6 caracteres" },
            { "Keystore.password.must.be.at.least.6.characters", "A senha da \u00E1rea de armazenamento de chaves deve ter, no m\u00EDnimo, 6 caracteres" },
            { "Keystore.provider.", "Fornecedor da \u00E1rea de armazenamento de chaves: " },
            { "Keystore.type.", "Tipo de \u00E1rea de armazenamento de chaves: " },
            { "Lists.entries.in.a.keystore", "Lista entradas em uma \u00E1rea de armazenamento de chaves" },
            { "Must.not.specify.both.v.and.rfc.with.list.command", "N\u00E3o devem ser especificados -v e -rfc com o comando 'list'" },
            { "Must.specify.alias", "Deve ser especificado um alias" },
            { "Must.specify.destination.alias", "Deve ser especificado um alias de destino" },
            { "NEWLINE", "\n" },
            { "NO", "N\u00C3O" },
            { "New.certificate.self.signed.", "Novo certificado (autoassinado):" },
            { "New.password.must.be.at.least.6.characters", "A nova senha deve ter, no m\u00EDnimo, 6 caracteres" },
            { "New.prompt.", "Nova {0}: " },
            { "No.certificate.from.the.SSL.server", "N\u00E3o \u00E9 um certificado do servidor SSL" },
            { "No.entries.from.identity.database.added", "Nenhuma entrada adicionada do banco de dados de identidades" },
            { "Not.X.509.certificate", "N\u00E3o \u00E9 um certificado X.509" },
            { "Not.a.signed.jar.file", "N\u00E3o \u00E9 um arquivo jar assinado" },
            { "Odd.number.of.hex.digits.found.", "Encontrado n\u00FAmero \u00EDmpar de seis d\u00EDgitos: " },
            { "Options.", "Op\u00E7\u00F5es:" },
            { "PKCS.10.with.weak", "Solicita\u00E7\u00E3o do Certificado PKCS #10 (Vers\u00E3o 1.0)\nAssunto: %1$s\nFormato: %2$s\nChave P\u00FAblica: %3$s\nAlgoritmo de assinatura: %4$s\n" },
            { "Password.is.too.short.must.be.at.least.6.characters", "A senha \u00E9 muito curta - deve ter, no m\u00EDnimo, 6 caracteres" },
            { "Passwords.must.differ", "As senhas devem ser diferentes" },
            { "Please.provide.keysize.for.secret.key.generation", "Forne\u00E7a o -keysize para a gera\u00E7\u00E3o da chave secreta" },
            { "Please.specify.srckeystore", "Especifique -srckeystore" },
            { "Prints.the.content.of.a.CRL.file", "Imprime o conte\u00FAdo de um arquivo CRL" },
            { "Prints.the.content.of.a.certificate", "Imprime o conte\u00FAdo de um certificado" },
            { "Prints.the.content.of.a.certificate.request", "Imprime o conte\u00FAdo de uma solicita\u00E7\u00E3o de certificado" },
            { "Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.", "Problema ao importar a entrada do alias {0}: {1}.\nEntrada do alias {0} n\u00E3o importada." },
            { "Public.keys.in.reply.and.keystore.don.t.match", "As chaves p\u00FAblicas da resposta e da \u00E1rea de armazenamento de chaves n\u00E3o correspondem" },
            { "Re.enter.new.password.", "Informe novamente a nova senha: " },
            { "Re.enter.new.prompt.", "Informe novamente a nova {0}: " },
            { "Re.enter.password.", "Redigite a senha: " },
            { "Reply.has.no.certificates", "A resposta n\u00E3o tem certificado" },
            { "SSL.server.host.and.port", "porta e host do servidor SSL" },
            { "STAR", "*******************************************" },
            { "STARNN", "*******************************************\n\n" },
            { "Secret.key.not.generated.alias.alias.already.exists", "Chave secreta n\u00E3o gerada; o alias <{0}> j\u00E1 existe" },
            { "Serial.ID.of.cert.to.revoke", "ID de s\u00E9rie do certificado a ser revogado" },
            { "Signature.", "Assinatura:" },
            { "Signer.d.", "Signat\u00E1rio #%d:" },
            { "Source.keystore.file.exists.but.is.empty.", "O arquivo da \u00E1rea de armazenamento de chaves de origem existe, mas est\u00E1 vazio: " },
            { "Submit.this.to.your.CA", "Submeter \u00E0 CA" },
            { "The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.", "O armazenamento de chaves pkcs12 de destino tem storepass e keypass diferentes. Tente novamente especificando -destkeypass." },
            { "They.don.t.match.Try.again", "Elas n\u00E3o correspondem. Tente novamente" },
            { "This.extension.cannot.be.marked.as.critical.", "Esta extens\u00E3o n\u00E3o pode ser marcada como cr\u00EDtica. " },
            { "Timestamp.", "Timestamp:" },
            { "Too.many.failures.Alias.not.changed", "Excesso de falhas. Alias n\u00E3o alterado" },
            { "Too.many.failures.Key.entry.not.cloned", "Excesso de falhas. Entrada da chave n\u00E3o clonada" },
            { "Too.many.failures.key.not.added.to.keystore", "Excesso de falhas - chave n\u00E3o adicionada a \u00E1rea de armazenamento de chaves" },
            { "Too.many.failures.try.later", "Excesso de falhas - tente mais tarde" },
            { "Too.many.retries.program.terminated", "Excesso de tentativas de repeti\u00E7\u00E3o; programa finalizado" },
            { "Top.level.certificate.in.reply.", "Certificado de n\u00EDvel superior na resposta:\n" },
            { "Trust.this.certificate.no.", "Confiar neste certificado? [n\u00E3o]:  " },
            { "Unknown.AccessDescription.type.", "Tipo de AccessDescription desconhecido: " },
            { "Unknown.Entry.Type", "Tipo de Entrada Desconhecido" },
            { "Unknown.extendedkeyUsage.type.", "Tipo de extendedkeyUsage desconhecido: " },
            { "Unknown.extension.type.", "Tipo de extens\u00E3o desconhecido: " },
            { "Unknown.keyUsage.type.", "Tipo de keyUsage desconhecido: " },
            { "Unknown.password.type.", "Tipo de senha desconhecido: " },
            { "Unrecognized.GeneralName.type.", "Tipo de GeneralName n\u00E3o reconhecido: " },
            { "Usage.error.no.command.provided", "Erro de uso: nenhum comando fornecido" },
            { "Use.keytool.command.name.help.for.usage.of.command.name", "Utilize \"keytool -command_name -help\" para uso de command_name.\nUtilize a op\u00E7\u00E3o -conf <url> para especificar um arquivo de op\u00E7\u00F5es pr\u00E9-configurado." },
            { "Use.keytool.help.for.all.available.commands", "Use \"keytool -help\" para todos os comandos dispon\u00EDveis" },
            { "Validity.must.be.greater.than.zero", "A validade deve ser maior do que zero" },
            { "Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.", "Advert\u00EAncia: Senhas de chave e de armazenamento diferentes n\u00E3o suportadas para KeyStores PKCS12. Ignorando valor {0} especificado pelo usu\u00E1rio." },
            { "Warning.Overwriting.existing.alias.alias.in.destination.keystore", "Advert\u00EAncia: Substitui\u00E7\u00E3o do alias {0} existente na \u00E1rea de armazenamento de chaves de destino" },
            { "What.is.the.name.of.your.City.or.Locality.", "Qual \u00E9 o nome da sua Cidade ou Localidade?" },
            { "What.is.the.name.of.your.State.or.Province.", "Qual \u00E9 o nome do seu Estado ou Munic\u00EDpio?" },
            { "What.is.the.name.of.your.organization.", "Qual \u00E9 o nome da sua empresa?" },
            { "What.is.the.name.of.your.organizational.unit.", "Qual \u00E9 o nome da sua unidade organizacional?" },
            { "What.is.the.two.letter.country.code.for.this.unit.", "Quais s\u00E3o as duas letras do c\u00F3digo do pa\u00EDs desta unidade?" },
            { "What.is.your.first.and.last.name.", "Qual \u00E9 o seu nome e o seu sobrenome?" },
            { "Wrong.answer.try.again", "Resposta errada; tente novamente" },
            { "X.509.extension", "extens\u00E3o X.509" },
            { "YES", "SIM" },
            { "Your.keystore.contains.keyStore.size.entries", "Sua \u00E1rea de armazenamento de chaves cont\u00E9m {0,number,integer} entradas" },
            { "Your.keystore.contains.keyStore.size.entry", "Sua \u00E1rea de armazenamento de chaves cont\u00E9m {0,number,integer} entrada" },
            { "access.the.cacerts.keystore", "acessar a \u00E1rea de armazenamento de chaves cacerts" },
            { "addprovider.option", "adicionar provedor de seguran\u00E7a por nome (por exemplo, SunPKCS11)\nconfigurar argumento para -addprovider" },
            { "alias.", "{0}, " },
            { "alias.has.no.X.509.certificate", "{0} n\u00E3o tem certificado X.509" },
            { "alias.has.no.public.key", "{0} n\u00E3o tem chave p\u00FAblica" },
            { "alias.has.no.public.key.certificate.", "{0} n\u00E3o tem chave p\u00FAblica (certificado)" },
            { "alias.in.cacerts", "Emissor <%s> no cacerts" },
            { "alias.in.keystore", "Emissor <%s>" },
            { "alias.keyStore.getCreationDate.alias.", "{0}, {1,date}, " },
            { "alias.name.of.the.entry.to.process", "nome do alias da entrada a ser processada" },
            { "backup.keystore.warning", "O backup do armazenamento de chaves original \"%1$s\" \u00E9 feito como \"%3$s\"..." },
            { "certificate.validity.start.date.time", "data/hora inicial de validade do certificado" },
            { "command.{0}.is.ambiguous.", "o comando {0} \u00E9 amb\u00EDguo:" },
            { "destination.alias", "alias de destino" },
            { "destination.key.password", "senha da chave de destino" },
            { "destination.keystore.name", "nome da \u00E1rea de armazenamento de chaves de destino" },
            { "destination.keystore.password", "senha da \u00E1rea de armazenamento de chaves de destino" },
            { "destination.keystore.password.protected", "senha protegida da \u00E1rea de armazenamento de chaves de destino" },
            { "destination.keystore.provider.name", "nome do fornecedor da \u00E1rea de armazenamento de chaves de destino" },
            { "destination.keystore.type", "tipo de \u00E1rea de armazenamento de chaves de destino" },
            { "distinguished.name", "nome distinto" },
            { "do.not.prompt", "n\u00E3o perguntar" },
            { "if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified", "se o alias n\u00E3o estiver especificado, destalias e srckeypass n\u00E3o dever\u00E3o ser especificados" },
            { "if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified", "se a \u00E1rea de armazenamento de chaves n\u00E3o estiver protegida por senha, ent\u00E3o -storepass, -keypass e -new n\u00E3o dever\u00E3o ser especificados" },
            { "if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified", "se -protected for especificado, ent\u00E3o -storepass, -keypass e -new n\u00E3o dever\u00E3o ser especificados" },
            { "if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified", "se a \u00E1rea de armazenamento de chaves de origem n\u00E3o estiver protegida por senha, ent\u00E3o -srcstorepass e -srckeypass n\u00E3o dever\u00E3o ser especificados" },
            { "if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified", "se -srcprotected for especificado, ent\u00E3o -srcstorepass e -srckeypass n\u00E3o dever\u00E3o ser especificados" },
            { "importing.keystore.status", "Importando armazenamento de chaves %1$s to %2$s..." },
            { "input.file.name", "nome do arquivo de entrada" },
            { "jks.storetype.warning", "O armazenamento de chaves %1$s usa um formato propriet\u00E1rio. \u00C9 recomendada a migra\u00E7\u00E3o para PKCS12, que \u00E9 um formato de padr\u00E3o industrial que usa \"keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\"." },
            { "key.algorithm.name", "nome do algoritmo da chave" },
            { "key.bit", "Chave %2$s de %1$d bits" },
            { "key.bit.size", "tamanho do bit da chave" },
            { "key.bit.weak", "Chave %2$s de %1$d bits (fraca)" },
            { "key.password", "senha da chave" },
            { "key.password.for.alias.", "senha da chave de <{0}>" },
            { "keystore.name", "nome da \u00E1rea de armazenamento de chaves" },
            { "keystore.password", "senha da \u00E1rea de armazenamento de chaves" },
            { "keystore.type", "tipo de \u00E1rea de armazenamento de chaves" },
            { "keytool.error.", "erro de keytool: " },
            { "migrate.keystore.warning", "\"%1$s\" foi migrado para %4$s. O backup do armazenamento de chaves %2$s \u00E9 feito como \"%3$s\"." },
            { "multiple.commands.1.2", "Somente um comando \u00E9 permitido: tanto %1$s quanto %2$s foram especificados." },
            { "n", "n" },
            { "new.password", "nova senha" },
            { "no", "n\u00E3o" },
            { "one.in.many", "%1$s #%2$d de %3$d" },
            { "option.1.set.twice", "A op\u00E7\u00E3o %s foi especificada v\u00E1rias vezes. Todas, exceto a \u00FAltima, ser\u00E3o ignoradas." },
            { "output.file.name", "nome do arquivo de sa\u00EDda" },
            { "output.in.RFC.style", "sa\u00EDda no estilo RFC" },
            { "password.through.protected.mechanism", "senha por meio de mecanismo protegido" },
            { "provclass.not.a.provider", "%s n\u00E3o \u00E9 um fornecedor" },
            { "provider.class.not.found", "Fornecedor \"%s\" n\u00E3o encontrado" },
            { "provider.class.option", "adicionar provedor de seguran\u00E7a por nome de classe totalmente qualificado\nconfigurar argumento para -providerclass" },
            { "provider.classpath", "classpath do fornecedor" },
            { "provider.name", "nome do fornecedor" },
            { "provider.name.not.found", "O fornecedor chamado \"%s\" n\u00E3o foi encontrado" },
            { "reply", "Resposta" },
            { "signature.algorithm.name", "nome do algoritmo de assinatura" },
            { "signed.jar.file", "arquivo jar assinado" },
            { "source.alias", "alias de origem" },
            { "source.key.password", "senha da chave de origem" },
            { "source.keystore.name", "nome da \u00E1rea de armazenamento de chaves de origem" },
            { "source.keystore.password", "senha da \u00E1rea de armazenamento de chaves de origem" },
            { "source.keystore.password.protected", "senha protegida da \u00E1rea de armazenamento de chaves de origem" },
            { "source.keystore.provider.name", "nome do fornecedor da \u00E1rea de armazenamento de chaves de origem" },
            { "source.keystore.type", "tipo de \u00E1rea de armazenamento de chaves de origem" },
            { "the.certificate", "O certificado" },
            { "the.certificate.request", "A solicita\u00E7\u00E3o do certificado" },
            { "the.crl", "A CRL" },
            { "the.generated.certificate", "O certificado gerado" },
            { "the.generated.certificate.request", "A solicita\u00E7\u00E3o do certificado gerada" },
            { "the.generated.crl", "A CRL gerada" },
            { "the.input", "A entrada" },
            { "the.issuer", "O emissor" },
            { "the.keystore.or.storetype.option.cannot.be.used.with.the.cacerts.option", "A op\u00E7\u00E3o -keystore ou -storetype n\u00E3o pode ser usada com a op\u00E7\u00E3o -cacerts" },
            { "the.tsa.certificate", "O certificado TSA" },
            { "trust.certificates.from.cacerts", "certificados confi\u00E1veis do cacerts" },
            { "unknown.size.1", "chave de tamanho desconhecido  %s" },
            { "validity.number.of.days", "n\u00FAmero de dias da validade" },
            { "verbose.output", "sa\u00EDda detalhada" },
            { "verified.by.s.in.s.weak", "Verificado por %1$s em %2$s com um %3$s" },
            { "warning.cacerts.option", "Advert\u00EAncia: use a op\u00E7\u00E3o -cacerts para acessar a \u00E1rea de armazenamento de chaves cacerts" },
            { "warning.not.verified.make.sure.keystore.is.correct", "ADVERT\u00CANCIA: n\u00E3o verificado. Certifique-se que -keystore esteja correto." },
            { "whose.key.risk", "%1$s usa um %2$s que \u00E9 considerado um risco \u00E0 seguran\u00E7a." },
            { "whose.sigalg.risk", "%1$s usa o algoritmo de assinatura %2$s que \u00E9 considerado um risco \u00E0 seguran\u00E7a." },
            { "with.weak", "%s (fraca)" },
            { "y", "s" },
            { "yes", "sim" },
        };
    }
}
